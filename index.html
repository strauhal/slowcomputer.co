<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Slow Computer Company</title>

  <!-- IBM Plex Sans -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@100;200;300;400;500;600;700&display=swap" rel="stylesheet">

<style>
  :root { 
    --bg: #fff; 
    --fg: #000; 
    --accent-alpha: rgba(0, 0, 0, 0.35);
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; width: 100%; }
  body {
    margin: 0;
    font-family: "IBM Plex Sans", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: var(--bg);
    color: var(--fg);
    overflow-x: hidden; /* Prevent horizontal scroll */
    display: flex;
    flex-direction: column;
  }

  /* FULL SCREEN ASCII */
  .ascii-bg {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg);
  }
  .ascii-bg pre {
    margin: 0;
    padding: 0;
    color: var(--fg);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: 12px;
    line-height: 1.0;
    white-space: pre;
    letter-spacing: .2px;
    user-select: none;
    -webkit-font-smoothing: antialiased;
    max-width: 100vw;
    max-height: 100vh;
    overflow: hidden;
    opacity: 0.8;
  }

  /* Center panel */
  .wrap {
    position: relative;
    z-index: 1;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    width: 100%;
  }
  .panel {
    width: 100%;
    max-width: 700px;
    border: 1px solid var(--fg);
    background: var(--bg);
    padding: 20px;
    /* Keeps panel centered even if content is small */
    margin: auto; 
  }
  .topbar {
    border-bottom: 1px solid var(--fg);
    padding-bottom: 10px;
    margin-bottom: 12px;
  }
  .info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 7px 12px;
    font-size: 11px;
    line-height: 1.2;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: .06em;
    opacity: .9;
  }
  .kv { display: flex; gap: 8px; min-width: 0; }
  .k { opacity: .65; white-space: nowrap; }
  .v { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; }

  @media (max-width: 720px) {
    .info { grid-template-columns: 1fr; }
    .panel { padding: 15px; }
  }

  h1 {
    margin: 0;
    font-weight: 100;
    /* Larger size for the title */
    font-size: clamp(38px, 10vw, 72px); 
    letter-spacing: -0.03em;
    line-height: 1.0;
    text-transform: lowercase;
    word-wrap: break-word;
  }

  /* Key Fix: Allow the scrambled text to wrap */
  .scramble { 
    display: inline; /* Changed from inline-block */
    position: relative; 
    white-space: normal; /* Changed from pre to allow wrapping */
    word-break: keep-all; /* Prevents breaking words in the middle */
  }

  .scramble .ghost {
    position: absolute;
    inset: auto 0 -0.15em 0;
    height: 1px;
    background: var(--accent-alpha);
  }

  .subtitle {
    margin: 15px 0 0;
    font-size: clamp(16px, 4vw, 20px);
    font-weight: 300;
    max-width: 62ch;
    border-left: 6px solid var(--fg);
    padding-left: 12px;
  }
  
  .link-p {
    text-transform: lowercase;
    margin-top: 12px;
  }
  .link-p a {
    color: inherit;
    text-decoration: none;
  }
  .link-p a:hover {
    text-decoration: underline;
  }
  .link-p span {
    text-transform: none;
  }

  .hr { margin: 20px 0 0; height: 1px; background: var(--fg); }

  @media (prefers-reduced-motion: reduce) {
    .ascii-bg { display: none; }
  }
</style>
</head>
<body>
  <div class="ascii-bg" aria-hidden="true">
    <pre id="ascii">loading…</pre>
  </div>

  <main class="wrap">
    <section class="panel" role="region" aria-label="The Slow Computer Company">
      <div class="topbar">
        <div class="info" id="info"></div>
      </div>

      <h1><span class="scramble" id="title" aria-label="the slow computer company"></span></h1>
 <br>
      <p class="subtitle link-p">
        <a href="https://github.com/strauhal/slowOS" target="_blank" rel="noopener">
          demo slow<span>OS</span> on github
        </a>
      </p>
      
      <div class="hr"></div>
    </section>
  </main>

  <script>
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const fract = (v)=>v - Math.floor(v);

    // --- Title scramble ---
    (function(){
      const el = document.getElementById("title");
      const target = "the slow computer company";
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{};:,.<>/?|~░▒▓█";
      const framesPerChar = 16;
      const stagger = 2;
      const delayMs = 70;
      let frame = 0;

      el.innerHTML = `<span id="scr"></span><span class="ghost" aria-hidden="true"></span>`;
      const scr = document.getElementById("scr");
      const randChar = () => chars[(Math.random()*chars.length)|0];

      function tick(){
        let out = "";
        for(let i=0;i<target.length;i++){
          const start = i * stagger;
          const end = start + framesPerChar;
          if(frame < start) out += " ";
          else if(frame >= end) out += target[i];
          else {
            const p = (frame - start) / framesPerChar;
            const bias = Math.min(0.85, p*p);
            out += (Math.random() < bias) ? target[i] : randChar();
          }
        }
        scr.textContent = out;

        frame++;
        if(frame <= (target.length * stagger + framesPerChar + 10)) setTimeout(tick, delayMs);
        else scr.textContent = target;
      }
      tick();
    })();

    // --- Browser info ---
    (function(){
      const info = document.getElementById("info");
      const n = navigator;
      const c = n.connection || n.mozConnection || n.webkitConnection;

      const rows = [
        ["ua", n.userAgent],
        ["vendor", n.vendor || "—"],
        ["platform", n.platform || "—"],
        ["timezone", (Intl.DateTimeFormat().resolvedOptions().timeZone || "—")],
        ["screen", `${screen.width}×${screen.height}`],
        ["viewport", `${window.innerWidth}×${window.innerHeight}`],
        ["cores", (n.hardwareConcurrency ? String(n.hardwareConcurrency) : "—")],
        ["online", (n.onLine ? "yes" : "no")],
        ["connection", c ? `${c.effectiveType || "—"} / dl ${c.downlink || "—"}` : "—"],
      ];

      function render(){
        info.innerHTML = rows.map(([k,v]) => `
          <div class="kv" title="${String(v).replaceAll('"','&quot;')}">
            <div class="k">${k}</div><div class="v">${String(v)}</div>
          </div>
        `).join("");
      }
      render();

      window.addEventListener("resize", () => {
        const vp = rows.find(r => r[0] === "viewport");
        if (vp) vp[1] = `${window.innerWidth}×${window.innerHeight}`;
        render();
      }, {passive:true});
    })();

    // --- ASCII Background ---
    (function(){
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

      const pre = document.getElementById("ascii");
      const repo = "strauhal/strauh.al3.1";
      const path = "2000s";
      const apiURL = `https://api.github.com/repos/${repo}/contents/${path}`;
      const ramp = "  .:-=+*#%@█";

      function calcGrid(){
        const cols = Math.max(90, Math.floor(window.innerWidth / 8.3));
        const rows = Math.max(28, Math.floor(window.innerHeight / 14.0));
        return { cols, rows };
      }

      function imgToASCIILines(img, cols, rows){
        const canvas = document.createElement("canvas");
        canvas.width = cols; canvas.height = rows;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        const iw = img.naturalWidth, ih = img.naturalHeight;
        const targetAspect = cols / rows;
        const imgAspect = iw / ih;

        let sx=0, sy=0, sw=iw, sh=ih;
        if (imgAspect > targetAspect){ sw = Math.floor(ih * targetAspect); sx = Math.floor((iw - sw) / 2); }
        else { sh = Math.floor(iw / targetAspect); sy = Math.floor((ih - sh) / 2); }

        ctx.drawImage(img, sx, sy, sw, sh, 0, 0, cols, rows);
        const { data } = ctx.getImageData(0, 0, cols, rows);

        const out = new Array(rows);
        for(let y=0;y<rows;y++){
          let line = "";
          for(let x=0;x<cols;x++){
            const i = (y*cols + x)*4;
            const lum = (0.2126*data[i] + 0.7152*data[i+1] + 0.0722*data[i+2]) / 255;
            const idx = clamp(Math.floor((1 - lum) * (ramp.length - 1)), 0, ramp.length - 1);
            line += ramp[idx];
          }
          out[y] = line;
        }
        return out;
      }

      async function fetchImageList(){
        const res = await fetch(apiURL, { headers: { "Accept": "application/vnd.github+json" } });
        if(!res.ok) throw new Error(`GitHub API ${res.status}`);
        const items = await res.json();
        const exts = [".png",".jpg",".jpeg",".webp",".gif"];
        return items
          .filter(x => x && x.type === "file" && exts.some(e => (x.name || "").toLowerCase().endsWith(e)))
          .map(x => x.download_url)
          .filter(Boolean);
      }

      function loadImage(url){
        return new Promise((resolve, reject) => {
          const img = new Image(); img.crossOrigin = "anonymous";
          img.onload = () => resolve(img); img.onerror = () => reject(new Error("fail"));
          img.src = url;
        });
      }

      function renderBoatMix(linesA, linesB, t, timeSec){
        const rows = linesA.length; const cols = linesA[0].length;
        const swayX = Math.sin(timeSec * 0.85) * 3.2 + Math.sin(timeSec * 2.05) * 1.3;
        const bobY  = Math.sin(timeSec * 1.05) * 1.4 + Math.sin(timeSec * 2.35) * 0.7;
        const shear = Math.sin(timeSec * 0.7) * 0.07;
        const seamBase = t * cols;
        const seamAmp  = 12 + 7*Math.sin(timeSec*0.33);
        const seamFreq = 0.11;
        const band = 8.0;
        const out = new Array(rows);
        const tf = Math.floor(timeSec * 24);

        for(let y=0;y<rows;y++){
          const rowSway = swayX + (y - rows/2) * shear;
          const ya = clamp(y + Math.round(bobY), 0, rows-1);
          const seam = seamBase + Math.sin(timeSec*0.9 + y*seamFreq) * seamAmp + Math.sin(timeSec*1.8 + y*seamFreq*1.7) * (seamAmp*0.35);

          let line = "";
          for(let x=0;x<cols;x++){
            const xa = clamp(x + Math.round(rowSway), 0, cols-1);
            const d = x - seam;
            let w;
            if (d < -band) w = 1;
            else if (d > band) w = 0;
            else {
              const u = (d + band) / (2*band);
              const smooth = 1 - (u*u*(3 - 2*u));
              const foam = 0.10 * Math.sin(timeSec*4.0 + x*0.20 + y*0.16) + 0.07 * Math.sin(timeSec*2.5 + x*0.08 - y*0.21);
              w = clamp(smooth + foam, 0, 1);
            }
            const r = fract(Math.sin((x*12.9898 + y*78.233 + tf*37.719))*43758.5453);
            line += (r < w) ? linesB[ya][xa] : linesA[ya][xa];
          }
          out[y] = line;
        }
        pre.textContent = out.join("\n");
      }

      let urls = [], idx = 0, cols = 0, rows = 0, A = null, B = null, linesA = null, linesB = null, t = 0;
      
      // Morph speed: higher is faster.
      const drift = 0.090; 
      const wobble = 0.22;

      async function ensureGrid(){ const g = calcGrid(); cols = g.cols; rows = g.rows; }

      async function loadPair(){
        const urlA = urls[idx % urls.length];
        const urlB = urls[(idx + 1) % urls.length];
        const [imgA, imgB] = await Promise.all([loadImage(urlA), loadImage(urlB)]);
        A = imgA; B = imgB;
        linesA = imgToASCIILines(A, cols, rows).map(s => s.padEnd(cols, " "));
        linesB = imgToASCIILines(B, cols, rows).map(s => s.padEnd(cols, " "));
      }

      let advancing = false;
      async function advanceOne(){
        if (advancing) return;
        advancing = true;
        try {
          idx = (idx + 1) % urls.length;
          t = 0;
          A = B; linesA = linesB;
          const imgNewB = await loadImage(urls[(idx + 1) % urls.length]);
          B = imgNewB;
          linesB = imgToASCIILines(B, cols, rows).map(s => s.padEnd(cols, " "));
        } finally { advancing = false; }
      }

      let last = performance.now();
      function loop(now){
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;
        if(linesA && linesB){
          t += drift * dt;
          const timeSec = now / 1000;
          const tMix = clamp(t + wobble * ((0.5 + 0.5 * Math.sin(timeSec * 0.55)) - 0.5), 0, 1);
          renderBoatMix(linesA, linesB, tMix, timeSec);
          if(t >= 1) { t = 0.95; advanceOne().catch(()=>{}); }
        }
        requestAnimationFrame(loop);
      }

      async function start(){
        try {
          await ensureGrid();
          urls = await fetchImageList();
          if(!urls.length) return;
          idx = Math.floor(Math.random() * urls.length);
          await loadPair();
          requestAnimationFrame(loop);
        } catch(e) { pre.textContent = "visualizer offline."; }
      }

      window.addEventListener("resize", () => {
        (async () => {
          if(!urls.length) return;
          await ensureGrid();
          if(A && B){
            linesA = imgToASCIILines(A, cols, rows).map(s => s.padEnd(cols, " "));
            linesB = imgToASCIILines(B, cols, rows).map(s => s.padEnd(cols, " "));
          }
        })().catch(()=>{});
      }, {passive:true});

      start();
    })();
  </script>
</body>
</html>